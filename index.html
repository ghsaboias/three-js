<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NewsMap Globe</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        max-width: 300px;
        word-wrap: break-word;
      }
      #info a {
        cursor: pointer;
        color: #3498db;
        text-decoration: underline;
      }
      #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        color: white;
        font-family: Arial, sans-serif;
      }
      #log {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        height: 100px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        font-family: monospace;
        padding: 10px;
        overflow-y: auto;
        border-radius: 5px;
      }
      #pauseButton {
        position: absolute;
        bottom: 120px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-family: Arial, sans-serif;
      }
      #animationControls {
        position: absolute;
        bottom: 120px;
        left: 120px;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        display: flex;
        align-items: center;
      }
      #animationSlider {
        width: 200px;
        margin: 0 10px;
      }
      #fetchButton {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: Arial, sans-serif;
        margin-left: 10px;
      }

      #newsAmount {
        width: 50px;
      }
    </style>
  </head>
  <body>
    <div id="info"></div>
    <div id="controls">
      <select id="newsSource">
        <option value="top-headlines">Top Headlines</option>
        <option value="everything">Everything</option>
      </select>
      <select id="category">
        <option value="general">General</option>
        <option value="business">Business</option>
        <option value="technology">Technology</option>
        <option value="sports">Sports</option>
        <option value="entertainment">Entertainment</option>
        <option value="science">Science</option>
        <option value="health">Health</option>
      </select>
      <select id="country">
        <option value="us">USA</option>
        <option value="gb">UK</option>
        <option value="in">India</option>
        <option value="au">Australia</option>
        <option value="ca">Canada</option>
        <option value="br">Brazil</option>
      </select>
      <select id="source" style="display: none">
        <option value="bbc-news">BBC News</option>
        <option value="cnn">CNN</option>
        <option value="fox-news">Fox News</option>
        <option value="google-news">Google News</option>
      </select>
      <label for="newsAmount">Number of news:</label>
      <input type="number" id="newsAmount" min="1" max="10" value="2" />
      <button id="fetchButton">Fetch News</button>
    </div>
    <div id="log"></div>
    <button id="pauseButton">Pause</button>
    <div id="animationControls">
      <input type="range" id="animationSlider" min="0" max="360" value="0" />
      <span id="sliderValue" style="color: white">0°</span>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const BACKEND_URL = "http://localhost:3000";

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const geometry = new THREE.SphereGeometry(5, 64, 64);
      const loader = new THREE.TextureLoader();
      const texture = loader.load(
        "https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg"
      );
      const material = new THREE.MeshPhongMaterial({ map: texture });
      const earth = new THREE.Mesh(geometry, material);
      scene.add(earth);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(50, 50, 50);
      scene.add(pointLight);

      camera.position.z = 15;

      function latLonToVector3(lat, lon) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const x = -(5.1 * Math.sin(phi) * Math.cos(theta));
        const z = 5.1 * Math.sin(phi) * Math.sin(theta);
        const y = 5.1 * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      }

      async function askClaude(article) {
        const prompt = `
            Analyze the following news article and determine the most relevant geographical location (city and country) it pertains to. If multiple locations are mentioned, choose the most significant one. If no specific location is mentioned, suggest the most likely location based on the content. Then, provide the latitude and longitude coordinates for this location.

            Article Title: ${article.title}
            Article Description: ${article.description}
            
            Respond exactly in the following format:
            Location: [City], [Country]
            Latitude: [Latitude]
            Longitude: [Longitude]
            Reasoning: [Brief explanation of your choice]
        `;

        try {
          const response = await fetch(`${BACKEND_URL}/ask-claude`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ prompt: prompt }),
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          console.log("Response from Claude API:", data);

          if (data.content && data.content[0] && data.content[0].text) {
            return data.content[0].text;
          } else {
            throw new Error("Unexpected response format from Claude API");
          }
        } catch (error) {
          console.error("Error calling Claude API:", error);
          log(`Error calling Claude API: ${error.message}`);
          return null;
        }
      }

      async function addNewsMarkers(newsData) {
        const newsAmount = parseInt(
          document.getElementById("newsAmount").value
        );
        const selectedNews = newsData.slice(0, newsAmount);
        earth.children = []; // Clear existing markers
        let addedMarkers = 0;
        for (const news of selectedNews) {
          const claudeResponse = await askClaude(news);
          if (claudeResponse) {
            try {
              const lines = claudeResponse
                .split("\n")
                .map((line) => line.trim())
                .filter((line) => line !== "");

              let location, lat, lon;
              for (const line of lines) {
                if (line.toLowerCase().startsWith("location:")) {
                  location = line.split(":").slice(1).join(":").trim();
                } else if (line.toLowerCase().startsWith("latitude:")) {
                  lat = parseFloat(line.split(":")[1]);
                } else if (line.toLowerCase().startsWith("longitude:")) {
                  lon = parseFloat(line.split(":")[1]);
                }
              }

              if (!location || isNaN(lat) || isNaN(lon)) {
                throw new Error("Unable to parse location information");
              }

              const markerGeometry = new THREE.SphereGeometry(0.07, 50, 50);
              const markerMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
              });
              const marker = new THREE.Mesh(markerGeometry, markerMaterial);
              const position = latLonToVector3(lat, lon);
              marker.position.set(position.x, position.y, position.z);

              // Create a larger invisible sphere for hit detection
              const hitGeometry = new THREE.SphereGeometry(0.2, 50, 50);
              const hitMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0,
              });
              const hitSphere = new THREE.Mesh(hitGeometry, hitMaterial);
              hitSphere.position.copy(marker.position);

              // Group the visible marker and invisible hit sphere
              const markerGroup = new THREE.Group();
              markerGroup.add(marker);
              markerGroup.add(hitSphere);
              markerGroup.userData = {
                title: news.title,
                url: news.url,
                source: news.source.name,
                location: location,
              };

              earth.add(markerGroup);
              addedMarkers++;
              log(
                `Added marker for article: "${news.title}" at ${location} (${lat}, ${lon})`
              );
            } catch (error) {
              log(
                `Error processing location for article: "${news.title}". Error: ${error.message}`
              );
            }
          } else {
            log(`Failed to get location for article: "${news.title}"`);
          }
        }
        log(`Added ${addedMarkers} news markers to the globe.`);
      }

      function log(message) {
        const logElement = document.getElementById("log");
        logElement.innerHTML += `${new Date().toISOString()}: ${message}<br>`;
        logElement.scrollTop = logElement.scrollHeight;
        console.log(message);
      }

      async function fetchNews() {
        const newsSource = document.getElementById("newsSource").value;
        let params = new URLSearchParams();

        if (newsSource === "top-headlines") {
          const category = document.getElementById("category").value;
          const country = document.getElementById("country").value;
          params.append("endpoint", "top-headlines");
          params.append("category", category);
          params.append("country", country);
        } else {
          const source = document.getElementById("source").value;
          params.append("endpoint", "everything");
          params.append("sources", source);
        }

        const url = `${BACKEND_URL}/api/news?${params.toString()}`;

        log(`Fetching news from URL: ${url}`);

        try {
          const response = await fetch(url);
          console.log(response);
          log(
            `Fetch response received. Status: ${response.status} ${response.statusText}`
          );

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          log(
            `JSON parsed successfully. Received ${data.articles.length} articles.`
          );

          await addNewsMarkers(data.articles);
        } catch (error) {
          log(`Error fetching news: ${error.name}: ${error.message}`);
          console.error("Full error object:", error);
        }
      }

      document
        .getElementById("newsSource")
        .addEventListener("change", function () {
          if (this.value === "top-headlines") {
            document.getElementById("category").style.display = "inline";
            document.getElementById("country").style.display = "inline";
            document.getElementById("source").style.display = "none";
          } else {
            document.getElementById("category").style.display = "none";
            document.getElementById("country").style.display = "none";
            document.getElementById("source").style.display = "inline";
          }
        });

      document
        .getElementById("fetchButton")
        .addEventListener("click", fetchNews);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      window.addEventListener("mousemove", onMouseMove, false);

      function onClick(event) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(earth.children, true);

        if (intersects.length > 0) {
          const intersectedObject = intersects[0].object;
          const markerGroup = intersectedObject.parent;
          if (markerGroup.userData && markerGroup.userData.title) {
            selectedMarker = markerGroup;
            updateInfoBox(markerGroup.userData);
          } else {
            selectedMarker = null;
            hideInfoBox();
          }
        } else {
          selectedMarker = null;
          hideInfoBox();
        }
      }
      window.addEventListener("click", onClick, false);

      function updateInfoBox(newsData) {
        const infoBox = document.getElementById("info");
        const news = newsData[0].object.userData;
        infoBox.innerHTML = `
        <strong>${news.title}</strong><br>
        Location: ${news.location}<br>
        Source: ${news.source}<br>
        <a href="${news.url}" target="_blank">Read more</a>
    `;
        infoBox.style.display = "block";
      }

      function hideInfoBox() {
        const infoBox = document.getElementById("info");
        infoBox.style.display = "none";
      }

      let isPaused = false;
      const pauseButton = document.getElementById("pauseButton");
      const animationSlider = document.getElementById("animationSlider");
      const sliderValue = document.getElementById("sliderValue");
      let lastSliderValue = 0;
      let selectedMarker = null;

      pauseButton.addEventListener("click", () => {
        isPaused = !isPaused;
        pauseButton.textContent = isPaused ? "Resume" : "Pause";
      });

      animationSlider.addEventListener("input", () => {
        const rotation = (animationSlider.value * Math.PI) / 180;
        earth.rotation.y = rotation;
        sliderValue.textContent = `${animationSlider.value}°`;
      });

      function animate() {
        requestAnimationFrame(animate);

        if (!isPaused) {
          earth.rotation.y += 0.002;
          animationSlider.value = ((earth.rotation.y * 180) / Math.PI) % 360;
          sliderValue.textContent = `${Math.round(animationSlider.value)}°`;
        } else {
          const currentSliderValue = parseInt(animationSlider.value);
          if (currentSliderValue !== lastSliderValue) {
            earth.rotation.y = (currentSliderValue * Math.PI) / 180;
            lastSliderValue = currentSliderValue;
          }
        }

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(earth.children);

        // Update cursor style
        if (intersects.length > 0) {
          const intersectedObject = intersects[0].object;
          const markerGroup = intersectedObject.parent;
          if (markerGroup.userData && markerGroup.userData.title) {
            document.body.style.cursor = "pointer";
          } else {
            document.body.style.cursor = "default";
          }
        } else {
          document.body.style.cursor = "default";
        }

        // Keep selected marker's info box visible
        if (selectedMarker) {
          updateInfoBox([{ object: selectedMarker }]);
        }

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
